{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport React from \"react\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport * as R from 'ramda';\nimport { useCallback, useContext, useMemo, useState } from 'react';\nimport { addressValidationSchema } from \"../common/helpers\";\nimport cn from 'classnames';\nimport CreateCustomerAddressMutation from \"./graphql/create-customer-address.graphql\";\nimport { Form } from \"../common/Form\";\nimport { Formik } from 'formik';\nimport styles from \"./index.css\";\nimport { useMutation } from '@apollo/react-hooks';\nimport { UserContext } from \"../../../common/UserContext\";\nimport { useTranslation } from \"../../../../i18n\";\nexport function Add(props) {\n  const {\n    t\n  } = useTranslation();\n  const userCtx = useContext(UserContext);\n  const {\n    0: submitErrors,\n    1: setSubmitErrors\n  } = useState([]);\n  const [create] = useMutation(CreateCustomerAddressMutation);\n  const cancel = props.cancel;\n  const addressesRefetch = props.addressesRefetch;\n  const submit = useCallback(async values => {\n    let errors = [];\n\n    try {\n      const r = await create({\n        variables: {\n          address: _objectSpread({\n            address1: values.address1,\n            address2: values.address2,\n            city: values.city,\n            company: values.company,\n            country: values.country,\n            firstName: values.firstName,\n            lastName: values.lastName,\n            phone: values.phone,\n            province: values.province,\n            zip: values.zip\n          }, values.phone ? {\n            phone: values.phone\n          } : {}),\n          customerAccessToken: userCtx.accessToken\n        }\n      });\n      errors = R.compose(R.pluck('message'), R.pathOr([], ['customerUserErrors']))(r.data.customerAddressCreate);\n    } catch (e) {\n      errors = R.compose(R.pluck('message'), R.pathOr([], ['graphQLErrors']))(e) || [t('creatingAShippingAddressFailed')];\n    }\n\n    if (R.isEmpty(errors)) {\n      await addressesRefetch();\n      cancel();\n    } else setSubmitErrors(errors);\n  }, [addressesRefetch, cancel, create, t, userCtx.accessToken]);\n  const initialValues = {\n    address1: '',\n    address2: '',\n    city: '',\n    country: 'United States',\n    firstName: '',\n    lastName: '',\n    phone: '',\n    province: '',\n    zip: ''\n  };\n  const validationSchema = useMemo(() => addressValidationSchema(t), [t]);\n  return __jsx(\"div\", {\n    className: cn(styles.creatingCustomerAddressForm, props.className)\n  }, !R.isEmpty(submitErrors) && __jsx(\"div\", {\n    className: \"error-message\"\n  }, R.map(message => __jsx(\"div\", {\n    className: \"row\",\n    key: message\n  }, message), submitErrors)), __jsx(Formik, {\n    initialValues: initialValues,\n    validationSchema: validationSchema,\n    onSubmit: submit\n  }, __jsx(Form, {\n    className: \"form\",\n    cancel: cancel,\n    isAdd: true\n  })));\n}","map":null,"metadata":{},"sourceType":"module"}