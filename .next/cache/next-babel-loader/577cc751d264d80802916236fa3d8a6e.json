{"ast":null,"code":"import React from \"react\";\nvar __jsx = React.createElement;\nimport * as R from 'ramda';\nimport { isServer, prismicClient } from \"../../common/helpers\";\nimport { BlogPostCard } from \"../../common/BlogPostCard\";\nimport { Breadcrumbs } from \"../../common/Breadcrumbs\";\nimport { Button } from \"../../common/Button\";\nimport cn from 'classnames';\nimport { EmptyMessage } from \"../../common/EmptyMessage\";\nimport getConfig from 'next/config';\nimport { getHeroImagePath } from \"../../common/helpers\";\nimport { Layout } from \"../../common/Layout\";\nimport moment from 'moment';\nimport { Pagination } from \"./Pagination\";\nimport Prismic from 'prismic-javascript';\nimport { RichText } from 'prismic-reactjs';\nimport { Sidebar } from \"./Sidebar\";\nimport styles from \"./index.css\";\nimport { useMemo } from 'react';\nimport { usePopup } from \"../../common/hooks\";\nimport { useTranslation } from \"../../../i18n\";\nconst {\n  publicRuntimeConfig\n} = getConfig();\n\nconst blogHost = () => publicRuntimeConfig.NEXT_PUBLIC_BLOG_URL.replace(/https?:\\/\\//, '');\n\nfunction List(props) {\n  const {\n    t,\n    i18n\n  } = useTranslation();\n  const breadcrumbs = useMemo(() => {\n    const result = [{\n      as: '/',\n      href: '/',\n      title: t('allStories')\n    }];\n    if (props.tag) result.push({\n      as: null,\n      href: null,\n      title: props.tag\n    });\n    if (props.year && props.month) result.push({\n      as: null,\n      href: null,\n      title: moment(`${props.year}-${props.month}`, 'YYYY-M').locale(i18n.language || i18n.options['defaultLanguage']).format('MMMM YYYY')\n    });\n    return result;\n  }, [i18n.language, i18n.options, props.month, props.tag, props.year, t]);\n  const sidebarPopup = usePopup(false);\n  if (!props.posts) return __jsx(\"div\", null, t('loading'));\n  return __jsx(Layout, {\n    className: styles.list,\n    isBlogDomain: true\n  }, __jsx(Breadcrumbs, {\n    className: \"breadcrumbs\",\n    items: breadcrumbs\n  }), __jsx(Button, {\n    appearance: \"outline\",\n    className: \"button\",\n    onClick: sidebarPopup.show\n  }, t('showArchive')), __jsx(Sidebar, {\n    className: cn('sidebar', {\n      'is-shown': sidebarPopup.isShown\n    }),\n    close: sidebarPopup.close,\n    featuredTags: props.featuredTags,\n    selectedMonth: props.month,\n    selectedTag: props.tag,\n    selectedYear: props.year\n  }), __jsx(\"div\", {\n    className: \"list\"\n  }, props.posts.map(post => __jsx(BlogPostCard, {\n    as: `/${post.uid}`,\n    className: \"item\",\n    date: post.date,\n    href: `/[gender]?gender=${post.uid}`,\n    imagePath: getHeroImagePath(post.content),\n    key: post.uid,\n    slug: post.uid,\n    title: RichText.asText(post.title),\n    videoPath: R.pathOr('', ['video', 'url'], post)\n  })), props.totalPages > 1 && __jsx(Pagination, {\n    className: \"pagination\",\n    page: props.page,\n    pathname: props.pathname,\n    query: props.query,\n    totalPages: props.totalPages\n  }), props.posts.length === 0 && __jsx(EmptyMessage, {\n    className: \"empty-message\"\n  }, t('noBlogPostsFound'))));\n}\n\nList.getInitialProps = async params => {\n  const itemsPerPage = 15;\n  const page = Number(R.pathOr('1', ['query', 'page'], params));\n  const month = Number(R.path(['query', 'month'], params)) || null; // Blog URLs intersect with the URLs of the rest of the app\n\n  const year = Number(R.path(['query', 'gender'], params)) || null;\n  const tag = params.query.tagslug;\n  const featuredTags = R.compose(R.uniq, R.flatten, R.pluck('tags'))((await prismicClient(params.req).query([Prismic.Predicates.at('document.type', 'post')], {\n    page: 1,\n    pageSize: 100\n  })).results); // GraphQL API would not allow implementing the pagination like in the old blog\n\n  const postsResponse = await prismicClient(params.req).query([Prismic.Predicates.at('document.type', 'post'), ...(tag ? [Prismic.Predicates.at('document.tags', [tag])] : []), ...(month ? [Prismic.Predicates.month('my.post.date', month)] : []), ...(year ? [Prismic.Predicates.year('my.post.date', year)] : [])], {\n    orderings: '[my.post.date desc]',\n    page,\n    pageSize: itemsPerPage\n  });\n  const totalPages = postsResponse.total_pages;\n  const posts = R.map(result => R.merge(result.data, {\n    tags: result.tags,\n    uid: result.uid\n  }), postsResponse.results);\n  if ((isServer() ? params.req.headers.host : location.host) !== blogHost()) params.res.statusCode = 404;\n  return {\n    featuredTags,\n    hasPageTransition: true,\n    month,\n    page,\n    posts,\n    tag,\n    totalPages,\n    year\n  };\n};\n\nexport { List };","map":null,"metadata":{},"sourceType":"module"}