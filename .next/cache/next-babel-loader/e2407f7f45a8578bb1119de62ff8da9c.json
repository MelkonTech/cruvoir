{"ast":null,"code":"import React from \"react\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport * as R from 'ramda';\nimport { createContext, useCallback, useContext, useEffect, useMemo, useState } from 'react';\nimport { useMutation, useQuery } from '@apollo/react-hooks';\nimport AddToWishListMutation from \"./graphql/add-to-wishlist.graphql\";\nimport { AuthModalContext } from \"../AuthModalContext\";\nimport RemoveFromWishListMutation from \"./graphql/remove-from-wishlist.graphql\";\nimport { UserContext } from \"../UserContext\";\nimport WishListQuery from \"./graphql/wishlist.graphql\";\nexport const WishListContext = /*#__PURE__*/createContext({\n  add: () => null,\n  isWished: () => false,\n  list: [],\n  remove: () => null\n});\nexport function WishListContextProvider(props) {\n  const [addToWishList] = useMutation(AddToWishListMutation, {\n    context: {\n      isInternalAPI: true\n    }\n  });\n  const authModalCtx = useContext(AuthModalContext);\n  const [removeFromWishList] = useMutation(RemoveFromWishListMutation, {\n    context: {\n      isInternalAPI: true\n    }\n  });\n  const userCtx = useContext(UserContext);\n  const customerId = R.prop('id', userCtx.user);\n  const {\n    0: delayedAddProductId,\n    1: setAddDelayedProductId\n  } = useState(null);\n  const isCustomerLoggedIn = Boolean(userCtx.user);\n  const {\n    data,\n    loading\n  } = useQuery(WishListQuery, {\n    context: {\n      isInternalAPI: true\n    },\n    skip: !isCustomerLoggedIn,\n    variables: {\n      customerId: customerId\n    }\n  });\n  const list = loading || !isCustomerLoggedIn ? [] : data.wishlist; // When user is not loggedin all products are shown as non-wished â€” there is no way non-loggedin\n  // user will unwish a product\n\n  const add = useCallback(productId => {\n    if (!isCustomerLoggedIn) {\n      authModalCtx.setActive('signin');\n      setAddDelayedProductId(productId);\n      return;\n    }\n\n    addToWishList({\n      optimisticResponse: {\n        __typename: 'mutation_root',\n        insert_wishlist: {\n          __typename: 'wishlist_mutation_response',\n          returning: [{\n            __typename: 'wishlist',\n            customer_id: customerId,\n            // The pair of customerId: str and productId: str is unique on DB side\n            id: customerId + productId,\n            product_id: productId\n          }]\n        }\n      },\n      update: (proxy, response) => {\n        const chacheQueryParams = {\n          query: WishListQuery,\n          variables: {\n            customerId: customerId\n          }\n        };\n        const listFromCache = proxy.readQuery(chacheQueryParams);\n        proxy.writeQuery(_objectSpread(_objectSpread({}, chacheQueryParams), {}, {\n          data: {\n            wishlist: [...listFromCache.wishlist, ...response.data.insert_wishlist.returning]\n          }\n        }));\n      },\n      variables: {\n        customerId: customerId,\n        productId\n      }\n    });\n  }, [addToWishList, authModalCtx, customerId, isCustomerLoggedIn]);\n  const remove = useCallback(productId => {\n    removeFromWishList({\n      optimisticResponse: {\n        __typename: 'mutation_root',\n        delete_wishlist: {\n          __typename: 'wishlist_mutation_response',\n          returning: [{\n            __typename: 'wishlist',\n            customer_id: customerId,\n            id: R.find(R.propEq('product_id', productId), list).id,\n            product_id: productId\n          }]\n        }\n      },\n      update: proxy => {\n        const chacheQueryParams = {\n          query: WishListQuery,\n          variables: {\n            customerId: customerId\n          }\n        };\n        const listFromCache = proxy.readQuery(chacheQueryParams);\n        proxy.writeQuery(_objectSpread(_objectSpread({}, chacheQueryParams), {}, {\n          data: {\n            wishlist: R.reject(R.propEq('product_id', productId), listFromCache.wishlist)\n          }\n        }));\n      },\n      variables: {\n        customerId,\n        productId\n      }\n    });\n  }, [customerId, list, removeFromWishList]);\n  const isWished = useCallback(productId => R.any(R.propEq('product_id', productId), list), [list]);\n  const value = useMemo(() => ({\n    add,\n    isWished,\n    list,\n    remove\n  }), [add, isWished, list, remove]); // When user data arrives wish a product that was wished before sign in\n\n  useEffect(() => {\n    if (userCtx.user && delayedAddProductId) {\n      setAddDelayedProductId(null);\n      add(delayedAddProductId);\n    }\n  }, [add, delayedAddProductId, setAddDelayedProductId, userCtx]);\n  return __jsx(WishListContext.Provider, {\n    value: value\n  }, props.children);\n}","map":null,"metadata":{},"sourceType":"module"}