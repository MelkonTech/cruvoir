{"ast":null,"code":"import React from \"react\";\nvar __jsx = React.createElement;\nimport 'intersection-observer';\nimport * as R from 'ramda';\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport { BlogPostCard } from \"../../common/BlogPostCard\";\nimport { getHeroImagePath } from \"../../common/helpers\";\nimport { Header } from \"../common/Header\";\nimport { Layout } from \"../../common/Layout\";\nimport { Link } from \"../../common/Link\";\nimport Prismic from 'prismic-javascript';\nimport { prismicClient } from \"../../common/helpers\";\nimport { PromoCard } from \"../common/PromoCard\";\nimport { RichText } from 'prismic-reactjs';\nimport styles from \"./index.css\";\nimport { UnderlineWrapper } from \"../../common/UnderlineWrapper\";\nimport { useTranslation } from \"../../../i18n\";\nconst itemsPerPage = 6;\n\nfunction Home(props) {\n  const {\n    t\n  } = useTranslation();\n  const loadMoreRef = useRef();\n  const {\n    0: posts,\n    1: setPosts\n  } = useState(props.posts || []);\n  const {\n    0: page,\n    1: setPage\n  } = useState(1);\n  const {\n    0: isMorePostsLoading,\n    1: setIsMorePostsLoading\n  } = useState(false);\n  const fetchMore = useCallback(async () => {\n    setIsMorePostsLoading(true);\n    const postsResponse = await prismicClient().query([Prismic.Predicates.at('document.type', 'post'), Prismic.Predicates.not('my.post.is_top', true)], {\n      orderings: '[my.post.date desc]',\n      page: page + 1,\n      pageSize: itemsPerPage\n    });\n    const newPosts = R.map(result => R.mergeRight(result.data, {\n      uid: result.uid\n    }), postsResponse.results);\n    setPage(R.inc);\n    setPosts(loadedPosts => [...loadedPosts, ...newPosts]);\n    setIsMorePostsLoading(false);\n  }, [page]);\n  useEffect(() => {\n    if (isMorePostsLoading) return () => {};\n    const target = loadMoreRef.current;\n    const io = new IntersectionObserver(async entries => {\n      if (entries && entries[0].isIntersecting && page < props.totalPages) await fetchMore();\n    }, {\n      root: null,\n      rootMargin: '350px',\n      threshold: 1.0\n    });\n    io.observe(target);\n    return () => io.unobserve(target);\n  }, [fetchMore, isMorePostsLoading, page, props.totalPages]);\n  return __jsx(Layout, {\n    className: styles.list,\n    isBlogDomain: true\n  }, __jsx(\"div\", {\n    className: \"section type--top-stories\"\n  }, __jsx(Header, {\n    className: \"header\"\n  }, t('topStories')), __jsx(\"div\", {\n    className: \"list\"\n  }, props.topPosts.map(post => __jsx(PromoCard, {\n    as: `/${post.uid}`,\n    className: \"item\",\n    date: post.date,\n    description: RichText.asText(post.excerpt || []),\n    href: `/[gender]?gender=${post.uid}`,\n    imagePath: getHeroImagePath(post.content),\n    key: post.uid,\n    slug: post.uid,\n    tags: post.tags,\n    title: RichText.asText(post.title),\n    videoPath: R.pathOr('', ['video', 'url'], post)\n  })))), __jsx(\"div\", {\n    className: \"section type--more-stories\"\n  }, __jsx(Header, {\n    additionalContent: props.totalPages > itemsPerPage && __jsx(UnderlineWrapper, {\n      className: \"link\",\n      isPermanent: true\n    }, __jsx(Link, {\n      href: \"/posts\"\n    }, t('seeAllStories'))),\n    className: \"header\"\n  }, t('moreStories')), __jsx(\"div\", {\n    className: \"list\"\n  }, posts.map(post => __jsx(BlogPostCard, {\n    as: `/${post.uid}`,\n    className: \"item\",\n    date: post.date,\n    href: `/[gender]?gender=${post.uid}`,\n    imagePath: getHeroImagePath(post.content),\n    key: post.uid,\n    slug: post.uid,\n    title: RichText.asText(post.title),\n    videoPath: R.pathOr('', ['video', 'url'], post)\n  }))), __jsx(\"div\", {\n    className: \"intersection-observer-anchor\",\n    ref: loadMoreRef\n  }), isMorePostsLoading && __jsx(\"div\", {\n    className: \"loading-message\"\n  }, t('loading')), page === props.totalPages && __jsx(\"div\", {\n    className: \"empty-message\"\n  }, t('noBlogPostsFound'))));\n}\n\nHome.getInitialProps = async params => {\n  const topPostsResponse = await prismicClient(params.req).query([Prismic.Predicates.at('document.type', 'post'), Prismic.Predicates.at('my.post.is_top', true)], {\n    orderings: '[my.post.date desc]'\n  });\n  const postsResponse = await prismicClient(params.req).query([Prismic.Predicates.at('document.type', 'post'), Prismic.Predicates.not('my.post.is_top', true)], {\n    orderings: '[my.post.date desc]',\n    pageSize: itemsPerPage\n  });\n  return {\n    hasPageTransition: true,\n    posts: R.map(result => R.mergeRight(result.data, {\n      uid: result.uid\n    }), postsResponse.results),\n    topPosts: R.map(result => R.mergeRight(result.data, {\n      tags: result.tags,\n      uid: result.uid\n    }), topPostsResponse.results),\n    totalPages: postsResponse.total_pages\n  };\n};\n\nexport { Home };","map":null,"metadata":{},"sourceType":"module"}