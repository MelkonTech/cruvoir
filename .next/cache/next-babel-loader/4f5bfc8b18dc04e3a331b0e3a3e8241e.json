{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport React from \"react\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport * as R from 'ramda';\nimport { createContext, useCallback, useEffect, useMemo, useState } from 'react';\nimport { useApolloClient, useMutation, useQuery } from '@apollo/react-hooks';\nimport ApplyDiscountCodeMutation from \"./graphql/apply-discount-code.graphql\";\nimport { CartModal } from \"./CartModal\";\nimport CheckoutCreateMutation from \"./graphql/create-checkout.graphql\";\nimport CheckoutQuery from \"../graphql/checkout.graphql\";\nimport CheckoutUpdateMutation from \"./graphql/update-checkout.graphql\";\nimport { ConfirmModal } from \"./ConfirmModal\";\nimport Cookies from 'js-cookie';\nimport InventoryQuantityQuery from \"./graphql/inventory-quantity.graphql\";\nimport ProductQuery from \"./graphql/product.graphql\";\nimport RemoveDiscountCodeMutation from \"./graphql/remove-discount-code.graphql\";\nexport const CartContext = /*#__PURE__*/createContext({\n  addProduct: () => null,\n  addProductWithConfirm: () => null,\n  applyPromoCode: () => null,\n  cartItems: [],\n  checkoutId: '',\n  clearCart: () => null,\n  discount: null,\n  fetchInventoryQuantityOfProducts: () => null,\n  inventoryQuantityOfProducts: {},\n  itemsCount: 0,\n  openCart: () => null,\n  refetch: async () => null,\n  removeProduct: () => null,\n  removePromoCode: () => null,\n  subtotal: 0,\n  tax: 0,\n  total: 0,\n  updateProduct: () => null\n});\nexport function CartContextProvider(props) {\n  const {\n    0: addedProduct,\n    1: setAddedProduct\n  } = useState(null);\n  const {\n    0: checkoutId,\n    1: setCheckoutId\n  } = useState(props.initialValue.checkoutId);\n  const {\n    0: isConfirmShown,\n    1: setIsConfirmShown\n  } = useState(false);\n  const closeConfirmation = useCallback(() => setIsConfirmShown(false), []);\n  const {\n    0: isCartShown,\n    1: setIsCartShown\n  } = useState(false);\n  const closeCart = useCallback(() => setIsCartShown(false), []);\n  const openCart = useCallback(() => setIsCartShown(true), []);\n  const {\n    data,\n    refetch\n  } = useQuery(CheckoutQuery, {\n    skip: !checkoutId,\n    variables: {\n      id: checkoutId\n    }\n  });\n  const checkoutData = useMemo(() => checkoutId ? data : {}, [checkoutId, data]);\n  const [createCheckout] = useMutation(CheckoutCreateMutation);\n  const [updateCheckout] = useMutation(CheckoutUpdateMutation);\n  const [applyDiscountCode] = useMutation(ApplyDiscountCodeMutation);\n  const [removeDiscountCode] = useMutation(RemoveDiscountCodeMutation);\n  const apolloClient = useApolloClient();\n  const convertItemsForRead = useCallback(inputData => R.compose(R.pluck('node'), R.pathOr([], ['node', 'lineItems', 'edges']))(inputData), []);\n  const subtotal = parseFloat(R.pathOr('0', ['node', 'subtotalPriceV2', 'amount'], checkoutData));\n  const clearCart = useCallback(() => {\n    setCheckoutId('');\n    Cookies.remove('checkoutId');\n  }, []);\n  const discount = useMemo(() => R.compose(R.ifElse(Boolean, item => ({\n    code: item.node.code,\n    typename: item.node.value.__typename,\n    value: item.node.value.__typename === 'PricingPercentageValue' ? item.node.value.percentage : item.node.value.amount\n  }), () => ({\n    code: null,\n    typename: 'MoneyV2',\n    value: '0'\n  })), R.find(item => !!item.node.code))(R.pathOr([], ['node', 'discountApplications', 'edges'], checkoutData)), [checkoutData]); // The amount left to be paid. This is equal to the cost of the line items, taxes and shipping minus discounts and gift cards.\n\n  const total = parseFloat(R.pathOr('0', ['node', 'paymentDueV2', 'amount'], checkoutData));\n  const tax = parseFloat(R.pathOr('0', ['node', 'totalTaxV2', 'amount'], checkoutData));\n  const cartItems = useMemo(() => convertItemsForRead(checkoutData), [checkoutData, convertItemsForRead]);\n  const {\n    0: inventoryQuantityOfProducts,\n    1: setInventoryQuantityOfProducts\n  } = useState({});\n  const addProduct = useCallback(async params => {\n    try {\n      // Find a product’s variant based on its selected options.\n      const product = await apolloClient.query({\n        fetchPolicy: 'no-cache',\n        query: ProductQuery,\n        variables: {\n          handle: params.handle,\n          selectedOptions: R.map(key => ({\n            name: key,\n            value: params.values[key]\n          }), Object.keys(params.values))\n        }\n      });\n      const variantID = product.data.productByHandle.variantBySelectedOptions.id; // Prevent cart items quantity going over the stock\n      // Consider requested quantity and the quantity of the item that was already added\n\n      const newInventoryQuantityOfProduct = R.pathOr(1, [product.data.productByHandle.id, variantID], inventoryQuantityOfProducts) - params.quantity - R.compose(R.propOr(0, 'quantity'), R.find(cartItem => cartItem.variant.product.id === product.data.productByHandle.id && cartItem.variant.id === variantID))(cartItems);\n      if (newInventoryQuantityOfProduct < 0) console.log('Stock is empty!');\n      let result = null;\n\n      if (checkoutId && newInventoryQuantityOfProduct >= 0) {\n        // Check item variant already in cart\n        const idx = R.findIndex(item => item.variant.id === variantID, cartItems); // Prepare items which already in cart\n\n        const lineItems = R.map(item => ({\n          quantity: item.quantity,\n          variantId: item.variant.id\n        }), cartItems);\n        if (~idx) lineItems[idx].quantity += params.quantity;else lineItems.push({\n          quantity: params.quantity,\n          variantId: variantID\n        });\n        result = await updateCheckout({\n          variables: {\n            checkoutId: checkoutId,\n            lineItems: lineItems\n          }\n        });\n      } else if (newInventoryQuantityOfProduct >= 0) {\n        result = await createCheckout({\n          variables: {\n            input: {\n              lineItems: [{\n                quantity: params.quantity,\n                variantId: variantID\n              }]\n            }\n          }\n        });\n        setCheckoutId(result.data.checkoutCreate.checkout.id);\n        Cookies.set('checkoutId', result.data.checkoutCreate.checkout.id, {\n          expires: 30\n        }); // expires in days\n      }\n\n      setAddedProduct({\n        image: R.compose(R.path(['node']), R.head)(product.data.productByHandle.images.edges),\n        title: product.data.productByHandle.title,\n        vendor: product.data.productByHandle.vendor\n      });\n      await refetch();\n      return result;\n    } catch (e) {\n      console.error(e);\n    }\n  }, [apolloClient, cartItems, checkoutId, createCheckout, inventoryQuantityOfProducts, refetch, updateCheckout]);\n  const updateProduct = useCallback(async params => {\n    const cachedData = apolloClient.readQuery({\n      query: CheckoutQuery,\n      variables: {\n        id: checkoutId\n      }\n    });\n    const newSubtotal = R.compose(R.sum, R.map(cartItem => (cartItem.variant.id === params.variantID ? params.quantity : cartItem.quantity) * parseFloat(cartItem.variant.priceV2.amount.toString())))(cartItems);\n    apolloClient.writeQuery({\n      data: _objectSpread(_objectSpread({}, cachedData), {}, {\n        node: _objectSpread(_objectSpread({}, cachedData.node), {}, {\n          lineItems: _objectSpread(_objectSpread({}, cachedData.node.lineItems), {}, {\n            edges: R.map(item => _objectSpread(_objectSpread({}, item), {}, {\n              node: _objectSpread(_objectSpread({}, item.node), {}, {\n                quantity: item.node.variant.id === params.variantID ? params.quantity : item.node.quantity\n              })\n            }), cachedData.node.lineItems.edges)\n          }),\n          paymentDueV2: _objectSpread(_objectSpread({}, cachedData.node.paymentDueV2), {}, {\n            amount: newSubtotal\n          }),\n          subtotalPriceV2: _objectSpread(_objectSpread({}, cachedData.node.subtotalPriceV2), {}, {\n            amount: newSubtotal\n          })\n        })\n      }),\n      query: CheckoutQuery,\n      variables: {\n        id: checkoutId\n      }\n    });\n\n    try {\n      await updateCheckout({\n        variables: {\n          checkoutId: checkoutId,\n          lineItems: R.map(item => ({\n            quantity: item.variant.id === params.variantID ? params.quantity : item.quantity,\n            variantId: item.variant.id\n          }), convertItemsForRead(cachedData))\n        }\n      });\n    } catch (e) {\n      console.error(e); // Refetch only then request failed!\n\n      await refetch();\n    }\n  }, [checkoutId, apolloClient, cartItems, convertItemsForRead, refetch, updateCheckout]);\n  const removeProduct = useCallback(async variantID => {\n    // WARN read/write queries used for \"optimistic\" UI without races\n    const cachedData = apolloClient.readQuery({\n      query: CheckoutQuery,\n      variables: {\n        id: checkoutId\n      }\n    });\n    const newSubtotal = R.compose(R.sum, R.map(cartItem => cartItem.quantity * parseFloat(cartItem.variant.priceV2.amount.toString())), R.reject(cartItem => cartItem.variant.id === variantID))(cartItems);\n    apolloClient.writeQuery({\n      data: _objectSpread(_objectSpread({}, cachedData), {}, {\n        node: _objectSpread(_objectSpread({}, cachedData.node), {}, {\n          lineItems: _objectSpread(_objectSpread({}, cachedData.node.lineItems), {}, {\n            edges: R.filter(i => i.node.variant.id !== variantID, cachedData.node.lineItems.edges)\n          }),\n          paymentDueV2: _objectSpread(_objectSpread({}, cachedData.node.paymentDueV2), {}, {\n            amount: newSubtotal\n          }),\n          subtotalPriceV2: _objectSpread(_objectSpread({}, cachedData.node.subtotalPriceV2), {}, {\n            amount: newSubtotal\n          })\n        })\n      }),\n      query: CheckoutQuery,\n      variables: {\n        id: checkoutId\n      }\n    });\n\n    try {\n      await updateCheckout({\n        variables: {\n          checkoutId: checkoutId,\n          lineItems: R.compose(R.map(item => ({\n            quantity: item.quantity,\n            variantId: item.variant.id\n          })), R.filter(item => item.variant.id !== variantID))(convertItemsForRead(cachedData))\n        }\n      });\n    } catch (e) {\n      console.error(e); // Refetch only then request failed!\n\n      await refetch();\n    }\n  }, [checkoutId, apolloClient, cartItems, convertItemsForRead, refetch, updateCheckout]);\n  const addProductWithConfirm = useCallback(async params => {\n    setIsCartShown(false);\n    setIsConfirmShown(false);\n    const result = await addProduct(params);\n    setIsConfirmShown(true);\n    return result;\n  }, [addProduct]);\n  const fetchInventoryQuantityOfProducts = useCallback(async ids => {\n    // {<product id>: {<variant id>: <quantity>}}\n    setInventoryQuantityOfProducts(R.reduce((acc, product) => R.assoc( // Admin API returns decoded ids — decode them to base64 in order to match ids returned by Storefront API\n    btoa(product.id), R.compose(R.fromPairs, R.map(variant => [btoa(variant.node.id), variant.node.inventoryQuantity || 0]))(product.variants.edges), acc), {}, R.pathOr([], ['data', 'nodes'], await apolloClient.query({\n      context: {\n        isInternalAPI: true\n      },\n      query: InventoryQuantityQuery,\n      variables: {\n        ids: ids\n      }\n    }))));\n  }, [apolloClient]);\n  const applyPromoCode = useCallback(async code => {\n    try {\n      const r = await applyDiscountCode({\n        variables: {\n          checkoutId: checkoutId,\n          discountCode: code\n        }\n      });\n      const errors = R.compose(R.pluck('message'), R.pathOr([], ['checkoutUserErrors']))(r.data.checkoutDiscountCodeApplyV2);\n      if (R.length(errors)) return Promise.reject(errors[0]);\n    } catch (e) {\n      console.error(e);\n    }\n\n    await refetch();\n  }, [applyDiscountCode, checkoutId, refetch]);\n  const removePromoCode = useCallback(async () => {\n    try {\n      const r = await removeDiscountCode({\n        variables: {\n          checkoutId: checkoutId\n        }\n      });\n      const errors = R.compose(R.pluck('message'), R.pathOr([], ['checkoutUserErrors']))(r.data.checkoutDiscountCodeRemove);\n      if (R.length(errors)) return Promise.reject(errors[0]);\n    } catch (e) {\n      console.error(e);\n    }\n\n    await refetch();\n  }, [checkoutId, refetch, removeDiscountCode]);\n  const contextValue = useMemo(() => ({\n    addProduct: addProduct,\n    addProductWithConfirm: addProductWithConfirm,\n    applyPromoCode: applyPromoCode,\n    cartItems: cartItems,\n    checkoutId: checkoutId,\n    clearCart: clearCart,\n    discount: discount,\n    fetchInventoryQuantityOfProducts,\n    inventoryQuantityOfProducts,\n    itemsCount: cartItems.length,\n    openCart: openCart,\n    refetch: refetch,\n    removeProduct: removeProduct,\n    removePromoCode: removePromoCode,\n    shippingAddress: R.path(['node', 'shippingAddress'], checkoutData),\n    subtotal: subtotal,\n    tax: tax,\n    total: total,\n    updateProduct: updateProduct\n  }), [addProduct, addProductWithConfirm, applyPromoCode, cartItems, checkoutId, clearCart, discount, fetchInventoryQuantityOfProducts, inventoryQuantityOfProducts, openCart, refetch, removeProduct, removePromoCode, checkoutData, subtotal, tax, total, updateProduct]);\n  useEffect(() => {\n    let timeoutId;\n    if (isConfirmShown) timeoutId = setTimeout(() => setIsConfirmShown(false), 5000);\n    return () => clearTimeout(timeoutId);\n  }, [isConfirmShown]);\n  return __jsx(CartContext.Provider, {\n    value: contextValue\n  }, props.children, isCartShown && __jsx(CartModal, {\n    removeProduct: removeProduct,\n    updateProduct: updateProduct,\n    close: closeCart,\n    itemsCount: cartItems.length,\n    items: cartItems,\n    subtotal: contextValue.subtotal\n  }), isConfirmShown && __jsx(ConfirmModal, {\n    subtotal: contextValue.subtotal,\n    itemsCount: cartItems.length,\n    close: closeConfirmation,\n    product: addedProduct\n  }));\n}","map":null,"metadata":{},"sourceType":"module"}