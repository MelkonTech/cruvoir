{"ast":null,"code":"import React from \"react\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport * as R from 'ramda';\nimport * as Yup from 'yup';\nimport { appendURLQueryParams, dashToCamel, getGender, getUrlAs, getUrlHref, nameToHandle, objectToFetchPostParams, shopifyEdgesToProducts } from \"../../common/helpers\";\nimport { Fragment, useCallback, useContext, useEffect, useMemo, useState } from 'react';\nimport { AppliedFilters } from \"./AppliedFilters\";\nimport { Breadcrumbs } from \"../../common/Breadcrumbs\";\nimport { Button } from \"../../common/Button\";\nimport { CartContext } from \"../../common/CartContext\";\nimport cn from 'classnames';\nimport CollectionQuery from \"./graphql/collection.graphql\";\nimport { CurrencyContext } from \"../../common/CurrencyContext\";\nimport debounce from 'debounce';\nimport { Designers } from \"../../common/Designers\";\nimport { EmptyMessage } from \"../../common/EmptyMessage\";\nimport { Form } from \"./Form\";\nimport { Formik } from 'formik';\nimport { Icon } from \"../../common/Icon\";\nimport { Layout } from \"../../common/Layout\";\nimport { ProductCard } from \"../../common/ProductCard\";\nimport { Placeholder as ProductCardPlaceholder } from \"../../common/ProductCard/Placeholder\";\nimport ProductsNodesQuery from \"./graphql/products-nodes.graphql\";\nimport ProductsQuery from \"./graphql/products.graphql\";\nimport { Select } from \"../../common/form\";\nimport styles from \"./index.css\";\nimport { usePopup } from \"../../common/hooks\";\nimport { useQuery } from '@apollo/react-hooks';\nimport { useRouter } from 'next/router';\nimport { useTranslation } from \"../../../i18n\";\nimport { vendors } from \"../../../settings/vendors\";\nimport { WishListContext } from \"../../common/WishListContext\";\nconst defaultItemsPerPage = 24;\nexport function List(props) {\n  const router = useRouter();\n  const gender = getGender(router, props.isBlogDomain);\n  const isCollectionRequested = props.query.collection && props.query.collection !== 'all';\n  const isDesignerCollectionRequested = R.contains(props.query.collection, R.map(item => nameToHandle(item.title), vendors[gender]));\n  const wishListCtx = useContext(WishListContext);\n  const currencyCtx = useContext(CurrencyContext);\n  const {\n    0: itemsPerPage,\n    1: setItemsPerPage\n  } = useState(defaultItemsPerPage);\n  const showMore = useCallback(() => {\n    setItemsPerPage(itemsPerPage + defaultItemsPerPage);\n  }, [itemsPerPage]);\n  const sortingOrDefault = R.propOr('created_at,reverse', 'sorting', props.query);\n  const sortKey = useMemo(() => R.compose(R.head, R.split(','))(sortingOrDefault), [sortingOrDefault]);\n  const isReverseSorting = useMemo(() => R.compose(R.includes('reverse'))(sortingOrDefault), [sortingOrDefault]); // Wish list uses the same layout as category page\n\n  const {\n    data: wishListProductsData\n  } = useQuery(ProductsNodesQuery, {\n    skip: !props.isWishListRequested,\n    variables: {\n      ids: R.pluck('product_id', wishListCtx.list)\n    }\n  });\n  const {\n    data: productsData,\n    loading: productsLoading\n  } = useQuery(ProductsQuery, {\n    skip: isCollectionRequested || props.isWishListRequested,\n    variables: _objectSpread(_objectSpread({\n      first: itemsPerPage,\n      sortKey: sortKey.toUpperCase()\n    }, isReverseSorting ? {\n      reverse: true\n    } : {}), {}, {\n      query: R.compose(R.join(' AND '), R.filter(R.identity))([props.query.minPrice && `variants.price:>=${currencyCtx.convert({\n        from: currencyCtx.active,\n        to: 'USD',\n        value: Number(props.query.minPrice)\n      })}`, props.query.maxPrice && `variants.price:<=${currencyCtx.convert({\n        from: currencyCtx.active,\n        to: 'USD',\n        value: Number(props.query.maxPrice)\n      })}`, props.query.search && props.query.search, props.query.gender !== 'all' && `tag:\"${props.query.gender}\"`, props.query.category !== 'all' && `tag:\"${props.query.category}\"`, props.query.subcategory !== 'all' && `tag:\"${props.query.subcategory}\"`, props.query.tags && `(${props.query.tags.split(',').map(tag => `tag:\"${decodeURI(tag)}\"`).join(' OR ')})`, props.query.colors && `(${props.query.colors.split(',').map(tag => `tag:color_${tag}`).join(' OR ')})`, props.query.vendors && `(${props.query.vendors.split(',').map(vendor => `tag:${decodeURI(vendor)}`).join(' OR ')})`])\n    })\n  });\n  const {\n    0: collectionCursor,\n    1: setCollectionCursor\n  } = useState(null);\n  const {\n    data: collectionData,\n    loading: collectionLoading\n  } = useQuery(CollectionQuery, {\n    skip: !isCollectionRequested,\n    variables: {\n      after: collectionCursor,\n      handle: props.query.collection\n    }\n  });\n  const fetchedCollectionProducts = useMemo(() => R.pathOr([], ['collectionByHandle', 'products', 'edges'], collectionData), [collectionData]); // .cursor is required later on, so do not resolve down to .node here\n\n  const lastCollectionProductsCursor = useMemo(() => collectionData && !R.isEmpty(fetchedCollectionProducts) && R.last(fetchedCollectionProducts).cursor, [collectionData, fetchedCollectionProducts]); // Eagerly show collection products — in order to do SSR\n\n  const {\n    0: collectionProducts,\n    1: setCollectionProducts\n  } = useState(isCollectionRequested ? shopifyEdgesToProducts({\n    data: collectionData,\n    queryName: 'collectionByHandle'\n  }) : []); // While aggregating pages of a collection check the name of collection from the query string corresponds\n  // to the name of aggregated collection. This is required to reset aggregated collection products data whenURL changes.\n\n  const {\n    0: lastAggregatedCollectionName,\n    1: setLastAggregatedCollectionName\n  } = useState(props.query.collection);\n  const cartCtx = useContext(CartContext);\n  useEffect(() => {\n    setCollectionProducts(oldCollectionProducts => {\n      // Navigating from non-empty collection to another collection which is empty\n      if (lastAggregatedCollectionName !== props.query.collection && R.isEmpty(fetchedCollectionProducts)) {\n        setLastAggregatedCollectionName(props.query.collection);\n        return [];\n      } // collectionProducts is prefilled with the first page of data that passed in as useState() as a param\n      // This helps to avoid duplicating of the first page.\n\n\n      if (!(collectionData && !R.isEmpty(fetchedCollectionProducts) && R.prop('id', oldCollectionProducts[0]) !== collectionData.collectionByHandle.products.edges[0].node.id)) return oldCollectionProducts;\n      const products = shopifyEdgesToProducts({\n        data: collectionData,\n        queryName: 'collectionByHandle'\n      }); // Collection name has changed in the URL\n\n      if (lastAggregatedCollectionName !== props.query.collection) {\n        setLastAggregatedCollectionName(props.query.collection);\n        return products;\n      } // This triggers a fetch of the next collection page if one is available\n      // Collections has no query param, so in order to ensure filtering all products of a collection ust be fetched\n\n\n      if (R.pathOr(false, ['collectionByHandle', 'products', 'pageInfo', 'hasNextPage'], collectionData)) setCollectionCursor(lastCollectionProductsCursor);\n      return R.concat(oldCollectionProducts, products);\n    });\n  }, [collectionData, fetchedCollectionProducts, lastAggregatedCollectionName, lastCollectionProductsCursor, props.query.collection]);\n  useEffect(() => {\n    cartCtx.fetchInventoryQuantityOfProducts(R.pluck('id', shopifyEdgesToProducts({\n      data: productsData\n    })));\n  }, // eslint-disable-next-line react-hooks/exhaustive-deps\n  [productsData]); // Reset collection products array when collection is changed on category page\n\n  useEffect(() => setCollectionCursor(null), [collectionData]);\n  const page = R.pathOr(1, ['page'], props.query);\n  const checkTags = useCallback((filter, product) => {\n    const normalizedTags = R.map(R.compose(R.join('-'), R.split(' '), R.toLower))(R.propOr([], 'tags', product));\n    if (typeof filter === 'string') {\n      if (filter !== 'all') return R.includes(R.toLower(filter), normalizedTags);else return true;\n    } else return R.any(tag => R.includes(tag, filter))(normalizedTags);\n  }, []);\n  const normalizeQueryTags = useCallback(tags => R.compose(R.map(R.compose(R.join('-'), R.split(' '), decodeURI)), R.split(','))(tags), []);\n  const filterProductsOnClient = useCallback(R.pipe( // Filter by one or more designers\n  items => items.filter(item => props.query.vendors ? checkTags(normalizeQueryTags(props.query.vendors), item) : true), // By one or more tags\n  // Tags come after category and subcategory in hierarchy, for example — Clothing > Jackets > Leather Jackets\n  items => items.filter(item => props.query.tags ? checkTags(normalizeQueryTags(props.query.tags), item) : true), // By one or more colors\n  items => items.filter(item => props.query.colors ? checkTags(normalizeQueryTags(R.map(colorTag => `color_${colorTag}`, props.query.colors.split(',')).join(',')), item) : true), // By min price\n  items => items.filter(item => props.query.minPrice ? R.pathOr(0, ['priceRange', 'minVariantPrice', 'amount'], item) >= currencyCtx.convert({\n    from: currencyCtx.active,\n    to: 'USD',\n    value: Number(props.query.minPrice)\n  }) : true), // By max price\n  items => items.filter(item => props.query.maxPrice ? R.pathOr(0, ['priceRange', 'minVariantPrice', 'amount'], item) <= currencyCtx.convert({\n    from: currencyCtx.active,\n    to: 'USD',\n    value: Number(props.query.maxPrice)\n  }) : true), // By category and subcategory\n  items => items.filter(item => checkTags(props.query.subcategory, item)), items => items.filter(item => checkTags(props.query.category, item)), // By gender\n  items => items.filter(item => {\n    if (props.query.gender !== 'all') return checkTags(props.query.gender, item);else return true;\n  }), // Sort products\n  items => R.isEmpty(sortKey) ? items : items.sort((a, b) => {\n    if (sortKey === 'price') {\n      const aValue = Number(R.pathOr(0, ['priceRange', 'minVariantPrice', 'amount'], a));\n      const bValue = Number(R.pathOr(0, ['priceRange', 'minVariantPrice', 'amount'], b));\n      if (aValue > bValue) return 1;else if (aValue < bValue) return -1;else return 0;\n    }\n\n    if (!a || !b || a[sortKey] > b[sortKey]) return 1;else if (a[sortKey] < b[sortKey]) return -1;else return 0;\n  }), items => isReverseSorting ? R.reverse(items) : items), [checkTags, normalizeQueryTags, props.query]);\n  const filteredCollectionProducts = useMemo(() => filterProductsOnClient(collectionProducts), [collectionProducts, filterProductsOnClient]);\n  const filteredWishListProducts = useMemo(() => filterProductsOnClient(R.pathOr([], ['nodes'], wishListProductsData)), [filterProductsOnClient, wishListProductsData]);\n  const products = useMemo(() => {\n    const nonEmpty = R.filter(Boolean);\n    const slicePage = R.slice((page - 1) * itemsPerPage, page * itemsPerPage);\n    if (isCollectionRequested) return nonEmpty(slicePage(filteredCollectionProducts));else if (props.isWishListRequested) return nonEmpty(slicePage(filteredWishListProducts));else return nonEmpty(shopifyEdgesToProducts({\n      data: productsData\n    }));\n  }, [filteredCollectionProducts, filteredWishListProducts, isCollectionRequested, itemsPerPage, productsData, page, props.isWishListRequested]);\n  const urlBaseParams = useMemo(() => ({\n    category: props.query.category,\n    collection: props.query.collection,\n    gender: props.query.gender,\n    isWishListRequested: props.isWishListRequested,\n    subcategory: props.query.subcategory\n  }), [props.isWishListRequested, props.query]);\n  const {\n    t\n  } = useTranslation();\n  const pageInfo = R.path(['products', 'pageInfo'], productsData);\n  const hasClientFilteredProductsNextPage = useMemo(() => {\n    const hasNextPage = R.compose(R.not, R.isEmpty, R.slice(page * itemsPerPage, Infinity));\n    if (isCollectionRequested) return hasNextPage(filteredCollectionProducts);else if (props.isWishListRequested) return hasNextPage(filteredWishListProducts);\n    return false;\n  }, [itemsPerPage, filteredCollectionProducts, filteredWishListProducts, isCollectionRequested, page, props.isWishListRequested]);\n  const hasNextPage = isCollectionRequested || props.isWishListRequested ? hasClientFilteredProductsNextPage : R.prop('hasNextPage', pageInfo);\n  const collectionLinkQueryParams = {\n    category: 'all',\n    collection: props.query.collection,\n    gender: props.query.gender,\n    isWishListRequested: props.isWishListRequested,\n    subcategory: 'all'\n  };\n  const categoryLinkQueryParams = {\n    category: props.query.category,\n    collection: props.query.collection,\n    gender: props.query.gender,\n    isWishListRequested: props.isWishListRequested,\n    subcategory: 'all'\n  };\n  const submit = useCallback(values => {\n    const queryParams = _objectSpread(_objectSpread({}, props.query.search ? {\n      search: props.query.search\n    } : {}), values) || {};\n    const queryParamsString = R.compose(queryString => queryString.replace(/%2C/g, ','), objectToFetchPostParams, R.reject(R.isEmpty), R.map(encodeURIComponent))(queryParams);\n    router.push(appendURLQueryParams(getUrlHref(urlBaseParams), queryParamsString), appendURLQueryParams(getUrlAs(urlBaseParams), queryParamsString)); // Drop to the first page if data changed\n\n    setItemsPerPage(defaultItemsPerPage);\n  }, [props.query, router, urlBaseParams]);\n  const debounceSubmit = useMemo(() => debounce(submit, 1000), [submit]);\n  const getQueryParamArray = useCallback(paramName => R.compose(R.filter(Boolean), R.split(','), R.pathOr('', [paramName]))(props.query), [props.query]);\n  const initialValues = useMemo(() => ({\n    colors: getQueryParamArray('colors'),\n    maxPrice: R.propOr('', 'maxPrice', props.query),\n    minPrice: R.propOr('', 'minPrice', props.query),\n    sorting: sortingOrDefault,\n    tags: getQueryParamArray('tags'),\n    vendors: getQueryParamArray('vendors')\n  }), [getQueryParamArray, props.query, sortingOrDefault]);\n  const validationSchema = Yup.object().shape({\n    maxPrice: Yup.number().max(99999).min(1).test('max-bigger-than-min', t('maxPriceMustBeBiggerThan'), function (value) {\n      return !this.parent.maxPrice || !this.parent.minPrice || this.parent.minPrice < value;\n    }),\n    minPrice: Yup.number().max(99999).min(1)\n  });\n  const queryParamsString = R.compose(objectToFetchPostParams, R.reject(R.anyPass([R.isEmpty, R.isNil])))({\n    search: props.query.search\n  });\n  const filtersLgPopup = usePopup(true);\n  const filtersMdPopup = usePopup(false); // Eagerly show collection products — in order to do SSR\n\n  return __jsx(Layout, {\n    className: cn(styles.list, {\n      'has-sidebar': filtersLgPopup.isShown\n    })\n  }, __jsx(Breadcrumbs, {\n    className: \"breadcrumbs\",\n    isLastCrumbHidden: !props.query.search,\n    items: [...(isCollectionRequested ? [_objectSpread(_objectSpread({}, props.query.gender === 'all' ? {} : {\n      as: appendURLQueryParams(getUrlAs({\n        collection: props.query.collection\n      }), queryParamsString),\n      href: appendURLQueryParams(getUrlHref({\n        collection: props.query.collection\n      }), queryParamsString)\n    }), {}, {\n      title: R.pathOr('', ['collectionByHandle', 'title'], collectionData)\n    })] : []), ...(props.isWishListRequested ? [_objectSpread(_objectSpread({}, props.query.gender === 'all' ? {} : {\n      as: appendURLQueryParams(getUrlAs({\n        isWishListRequested: true\n      }), queryParamsString),\n      href: appendURLQueryParams(getUrlHref({\n        isWishListRequested: true\n      }), queryParamsString)\n    }), {}, {\n      title: t('wishList')\n    })] : []), ...(props.query.gender === 'all' ? [] : [_objectSpread(_objectSpread({}, props.query.category === 'all' ? {} : {\n      as: appendURLQueryParams(getUrlAs(collectionLinkQueryParams), queryParamsString),\n      href: appendURLQueryParams(getUrlHref(collectionLinkQueryParams), queryParamsString)\n    }), {}, {\n      title: t(props.query.gender)\n    })]), ...(props.query.category === 'all' ? [] : [_objectSpread(_objectSpread({}, props.query.subcategory === 'all' ? {} : {\n      as: appendURLQueryParams(getUrlAs(categoryLinkQueryParams), queryParamsString),\n      href: appendURLQueryParams(getUrlHref(categoryLinkQueryParams), queryParamsString)\n    }), {}, {\n      title: t(dashToCamel(props.query.category))\n    })]), ...(props.query.subcategory === 'all' ? [] : [{\n      title: t(dashToCamel(props.query.subcategory))\n    }]), {\n      title: props.query.search && `\"${props.query.search}\"` || t(props.query.subcategory.replace('all', '')) || t(props.query.category.replace('all', '')) || t(props.query.gender.replace('all', '')) ||\n      /* eslint-disable-next-line max-len */\n      (props.query.collection || '').replace('all', '') && R.path(['collectionByHandle', 'title'], collectionData) || t('wishList')\n    }]\n  }), __jsx(Formik, {\n    initialValues: initialValues,\n    enableReinitialize: true,\n    onSubmit: debounceSubmit,\n    validationSchema: validationSchema\n  }, __jsx(Fragment, null, __jsx(\"div\", {\n    className: \"header\"\n  }, __jsx(\"button\", {\n    className: cn('button resolution--lg', {\n      'is-collapsed': !filtersLgPopup.isShown\n    }),\n    onClick: filtersLgPopup.toggle\n  }, __jsx(\"span\", {\n    className: \"title\"\n  }, t('filterBy')), __jsx(\"div\", {\n    className: \"icons\"\n  }, __jsx(Icon, {\n    className: \"icon\",\n    name: \"filter-to-close\"\n  }), __jsx(Icon, {\n    className: \"icon\",\n    name: \"filter-to-open\"\n  }))), __jsx(\"button\", {\n    className: cn('button resolution--md', {\n      'is-collapsed': !filtersMdPopup.isShown\n    }),\n    onClick: filtersMdPopup.toggle\n  }, __jsx(\"span\", {\n    className: \"title\"\n  }, t('filterBy')), __jsx(\"div\", {\n    className: \"icons\"\n  }, __jsx(Icon, {\n    className: \"icon\",\n    name: \"filter-to-close\"\n  }), __jsx(Icon, {\n    className: \"icon\",\n    name: \"filter-to-open\"\n  }))), __jsx(AppliedFilters, {\n    className: \"applied-filters\"\n  }), !R.isEmpty(products) && __jsx(Select, {\n    className: \"field\",\n    isUppercase: true,\n    name: \"sorting\",\n    options: [{\n      label: t('createdNewestFirst'),\n      value: 'created_at,reverse'\n    }, {\n      label: t('createdOldestFirst'),\n      value: 'created_at'\n    }, {\n      label: t('updatedNewestFirst'),\n      value: 'updated_at,reverse'\n    }, {\n      label: t('updatedOldestFirst'),\n      value: 'updated_at'\n    }, {\n      label: t('vendorAZ'),\n      value: 'vendor'\n    }, {\n      label: t('vendorZA'),\n      value: 'vendor,reverse'\n    }]\n  })), __jsx(Form, {\n    className: cn('sidebar', {\n      'is-lg-shown': filtersLgPopup.isShown,\n      'is-md-shown': filtersMdPopup.isShown\n    }),\n    close: filtersMdPopup.close,\n    initialValues: initialValues,\n    isBlogDomain: props.isBlogDomain,\n    isDesignerCollectionRequested: isDesignerCollectionRequested,\n    isWishListRequested: props.isWishListRequested,\n    query: props.query\n  }))), __jsx(\"div\", {\n    className: \"content\"\n  }, (productsLoading || collectionLoading) && R.isEmpty(products) && __jsx(\"div\", {\n    className: \"list\"\n  }, R.map(i => __jsx(ProductCardPlaceholder, {\n    key: i\n  }), R.range(0, defaultItemsPerPage))), !R.isEmpty(products) && __jsx(Fragment, null, __jsx(\"div\", {\n    className: cn('list', {\n      'is-muted': productsLoading || collectionLoading && !collectionCursor\n    })\n  }, R.map(product => __jsx(ProductCard, {\n    className: \"card\",\n    key: product.id,\n    product: product\n  }), products)), __jsx(Button, {\n    appearance: \"outline\",\n    className: \"button\",\n    disabled: !hasNextPage,\n    disabledMessage: t('noMoreItemsToLoad'),\n    isLoading: productsLoading,\n    onClick: showMore\n  }, t('showMore'))), R.isEmpty(products) && !productsLoading && !collectionLoading && __jsx(EmptyMessage, {\n    className: \"empty-message\"\n  }, t('noProductsFound'))), __jsx(Designers, {\n    className: \"designers\",\n    isBlogDomain: props.isBlogDomain\n  }));\n}","map":null,"metadata":{},"sourceType":"module"}